package org.foxminded.springcourse.consoleapp.dao;

import org.foxminded.springcourse.consoleapp.annotation.Column;
import org.foxminded.springcourse.consoleapp.annotation.Id;
import org.foxminded.springcourse.consoleapp.annotation.Table;
import org.springframework.stereotype.Component;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class CrudQueryBuilderPostgres<T> implements CrudQueryBuilder<T> {

    private final EntityInformationCache entityInformationCache;

    public CrudQueryBuilderPostgres(EntityInformationCache entityInformationCache) {
        this.entityInformationCache = entityInformationCache;
    }

    @Override
    public String buildSaveQuery(T entity) {
        String queryTemplate = "INSERT INTO %s (%s) VALUES (%s) RETURNING %s;";
        EntityInformation entityInformation = getEntityInformation(entity);
        return String.format(queryTemplate,
                getTableName(entity),
                getColumnNamesExcludingId(entityInformation),
                getBindParameters(entityInformation),
                entityInformation.getIdColumn());
    }

    private String getColumnNamesExcludingId(EntityInformation entityInformation) {
        return String.join(", ", entityInformation.getUpdatableColumns());
    }

    private String getBindParameters(EntityInformation entityInformation) {
        return entityInformation.getUpdatableColumns().stream()
                .map(column -> "?")
                .collect(Collectors.joining(", "));
    }

    private EntityInformation getEntityInformation(T entity) {
        if (entityInformationCache.containsKey(entity.getClass())) {
            return entityInformationCache.get(entity.getClass());
        }
        List<String> idColumns = new ArrayList<>();
        List<String> updatableColumns = new ArrayList<>();
        List<String> columns = new ArrayList<>();
        for (Field field : entity.getClass().getDeclaredFields()) {
            Column columnAnnotation = field.getAnnotation(Column.class);
            if (columnAnnotation != null) {
                columns.add(columnAnnotation.name());
                Id idAnnotation = field.getAnnotation(Id.class);
                if (idAnnotation == null || !idAnnotation.autogenerated()) {
                    updatableColumns.add(columnAnnotation.name());
                } else {
                    idColumns.add(columnAnnotation.name());
                }
            }
        }
        checkIdColumnNamesCount(idColumns);
        String id = idColumns.get(0);
        EntityInformation information = new EntityInformation(id, columns, updatableColumns);
        entityInformationCache.put(entity.getClass(), information);
        return information;
    }

    private String getTableName(T entity) {
        Table table = entity.getClass().getAnnotation(Table.class);
        if (table == null) {
            String message = String.format("Entity %s must be annotated with %s",
                    entity.getClass(), Table.class);
            throw new IllegalArgumentException(message);
        }
        return table.name();
    }

    private void checkIdColumnNamesCount(List<String> idColumnNames) {
        if (idColumnNames.size() == 0) {
            throw new IllegalArgumentException("Id column must be specified");
        } else if (idColumnNames.size() > 1) {
            throw new IllegalArgumentException("Multiple Id specification found");
        }
    }
}
